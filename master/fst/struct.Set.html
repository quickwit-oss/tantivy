<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Set` struct in crate `fst`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Set">

    <title>fst::Set - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css"
          id="mainThemeStyle">
    
    <link rel="stylesheet" type="text/css" href="../dark.css">
    <link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
    <script src="../storage.js"></script>
    

    
    
</head>
<body class="rustdoc struct">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <div class="sidebar-menu">&#9776;</div>
        
        <p class='location'>Struct Set</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.from_path">from_path</a><a href="#method.from_bytes">from_bytes</a><a href="#method.from_iter">from_iter</a><a href="#method.contains">contains</a><a href="#method.stream">stream</a><a href="#method.range">range</a><a href="#method.search">search</a><a href="#method.len">len</a><a href="#method.is_empty">is_empty</a><a href="#method.op">op</a><a href="#method.is_disjoint">is_disjoint</a><a href="#method.is_subset">is_subset</a><a href="#method.is_superset">is_superset</a><a href="#method.as_fst">as_fst</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Debug">Debug</a><a href="#impl-AsRef%3CFst%3E">AsRef&lt;Fst&gt;</a><a href="#impl-IntoStreamer%3C%27a%3E">IntoStreamer&lt;&#39;a&gt;</a><a href="#impl-From%3CFst%3E">From&lt;Fst&gt;</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a></div></div><p class='location'><a href='index.html'>fst</a></p><script>window.sidebarCurrent = {name: 'Set', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div>
    </nav>

    <div class="theme-picker">
        <button id="theme-picker" aria-label="Pick another theme!">
            <img src="../brush.svg" width="18" alt="Pick another theme!">
        </button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content"><h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>fst</a>::<wbr><a class="struct" href=''>Set</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/fst/set.rs.html#32' title='goto source code'>[src]</a></span></h1><div class="docblock type-decl"><pre class='rust struct'>pub struct Set(_);</pre></div><div class='docblock'><p>Set is a lexicographically ordered set of byte strings.</p>
<p>A <code>Set</code> is constructed with the <code>SetBuilder</code> type. Alternatively, a <code>Set</code>
can be constructed in memory from a lexicographically ordered iterator
of byte strings (<code>Set::from_iter</code>).</p>
<p>A key feature of <code>Set</code> is that it can be serialized to disk compactly. Its
underlying representation is built such that the <code>Set</code> can be memory mapped
(<code>Set::from_path</code>) and searched without necessarily loading the entire
set into memory.</p>
<p>It supports most common operations associated with sets, such as
membership, union, intersection, subset/superset, etc. It also supports
range queries and automata based searches (e.g. a regular expression).</p>
<p>Sets are represented by a finite state transducer where output values are
always zero. As such, sets have the following invariants:</p>
<ol>
<li>Once constructed, a <code>Set</code> can never be modified.</li>
<li>Sets must be constructed with lexicographically ordered byte sequences.</li>
</ol>
</div>
                    <h2 id='methods' class='small-section-header'>
                      Methods<a href='#methods' class='anchor'></a>
                    </h2>
                <h3 id='impl' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="struct" href="../fst/struct.Set.html" title="struct fst::Set">Set</a></code><a href='#impl' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#34-310' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.from_path' class="method"><span id='from_path.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.from_path' class='fnname'>from_path</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(path: P) -&gt; <a class="type" href="../fst/type.Result.html" title="type fst::Result">Result</a>&lt;Self&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#42-44' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Opens a set stored at the given file path via a memory map.</p>
<p>The set must have been written with a compatible finite state
transducer builder (<code>SetBuilder</code> qualifies). If the format is invalid
or if there is a mismatch between the API version of this library
and the set, then an error is returned.</p>
</div><h4 id='method.from_bytes' class="method"><span id='from_bytes.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.from_bytes' class='fnname'>from_bytes</a>(bytes: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;) -&gt; <a class="type" href="../fst/type.Result.html" title="type fst::Result">Result</a>&lt;Self&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#54-56' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Creates a set from its representation as a raw byte sequence.</p>
<p>Note that this operation is very cheap (no allocations and no copies).</p>
<p>The set must have been written with a compatible finite state
transducer builder (<code>SetBuilder</code> qualifies). If the format is invalid
or if there is a mismatch between the API version of this library
and the set, then an error is returned.</p>
</div><h4 id='method.from_iter' class="method"><span id='from_iter.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.from_iter' class='fnname'>from_iter</a>&lt;T, I&gt;(iter: I) -&gt; <a class="type" href="../fst/type.Result.html" title="type fst::Result">Result</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/trait.IntoIterator.html" title="trait core::iter::traits::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#67-72' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Create a <code>Set</code> from an iterator of lexicographically ordered byte
strings.</p>
<p>If the iterator does not yield values in lexicographic order, then an
error is returned.</p>
<p>Note that this is a convenience function to build a set in memory.
To build a set that streams to an arbitrary <code>io::Write</code>, use
<code>SetBuilder</code>.</p>
</div><h4 id='method.contains' class="method"><span id='contains.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.contains' class='fnname'>contains</a>&lt;K:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, key: K) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#86-88' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Tests the membership of a single key.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">fst</span>::<span class="ident">Set</span>;

<span class="kw">let</span> <span class="ident">set</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">set</span>.<span class="ident">contains</span>(<span class="string">&quot;b&quot;</span>), <span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">set</span>.<span class="ident">contains</span>(<span class="string">&quot;z&quot;</span>), <span class="bool-val">false</span>);</pre>
</div><h4 id='method.stream' class="method"><span id='stream.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.stream' class='fnname'>stream</a>(&amp;self) -&gt; <a class="struct" href="../fst/set/struct.Stream.html" title="struct fst::set::Stream">Stream</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#117-119' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Return a lexicographically ordered stream of all keys in this set.</p>
<p>While this is a stream, it does require heap space proportional to the
longest key in the set.</p>
<p>If the set is memory mapped, then no further heap space is needed.
Note though that your operating system may fill your page cache
(which will cause the resident memory usage of the process to go up
correspondingly).</p>
<h1 id="example-1" class="section-header"><a href="#example-1">Example</a></h1>
<p>Since streams are not iterators, the traditional <code>for</code> loop cannot be
used. <code>while let</code> is useful instead:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">fst</span>::{<span class="ident">IntoStreamer</span>, <span class="ident">Streamer</span>, <span class="ident">Set</span>};

<span class="kw">let</span> <span class="ident">set</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">set</span>.<span class="ident">stream</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">keys</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">key</span>) <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">next</span>() {
    <span class="ident">keys</span>.<span class="ident">push</span>(<span class="ident">key</span>.<span class="ident">to_vec</span>());
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">keys</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">b&quot;a&quot;</span>, <span class="string">b&quot;b&quot;</span>, <span class="string">b&quot;c&quot;</span>]);</pre>
</div><h4 id='method.range' class="method"><span id='range.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.range' class='fnname'>range</a>(&amp;self) -&gt; <a class="struct" href="../fst/set/struct.StreamBuilder.html" title="struct fst::set::StreamBuilder">StreamBuilder</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#146-148' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Return a builder for range queries.</p>
<p>A range query returns a subset of keys in this set in a range given in
lexicographic order.</p>
<p>Memory requirements are the same as described on <code>Set::stream</code>.
Notably, only the keys in the range are read; keys outside the range
are not.</p>
<h1 id="example-2" class="section-header"><a href="#example-2">Example</a></h1>
<p>Returns only the keys in the range given.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">fst</span>::{<span class="ident">IntoStreamer</span>, <span class="ident">Streamer</span>, <span class="ident">Set</span>};

<span class="kw">let</span> <span class="ident">set</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">set</span>.<span class="ident">range</span>().<span class="ident">ge</span>(<span class="string">&quot;b&quot;</span>).<span class="ident">lt</span>(<span class="string">&quot;e&quot;</span>).<span class="ident">into_stream</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">keys</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">key</span>) <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">next</span>() {
    <span class="ident">keys</span>.<span class="ident">push</span>(<span class="ident">key</span>.<span class="ident">to_vec</span>());
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">keys</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">b&quot;b&quot;</span>, <span class="string">b&quot;c&quot;</span>, <span class="string">b&quot;d&quot;</span>]);</pre>
</div><h4 id='method.search' class="method"><span id='search.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.search' class='fnname'>search</a>&lt;A:&nbsp;<a class="trait" href="../fst/automaton/trait.Automaton.html" title="trait fst::automaton::Automaton">Automaton</a>&gt;(&amp;self, aut: A) -&gt; <a class="struct" href="../fst/set/struct.StreamBuilder.html" title="struct fst::set::StreamBuilder">StreamBuilder</a>&lt;A&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#191-193' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Executes an automaton on the keys of this set.</p>
<p>Note that this returns a <code>StreamBuilder</code>, which can be used to
add a range query to the search (see the <code>range</code> method).</p>
<p>Memory requirements are the same as described on <code>Set::stream</code>.</p>
<h1 id="example-3" class="section-header"><a href="#example-3">Example</a></h1>
<p>An implementation of regular expressions for <code>Automaton</code> is available
in the <code>fst-regex</code> crate, which can be used to search sets.</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">fst</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">fst_regex</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;

<span class="kw">use</span> <span class="ident">fst</span>::{<span class="ident">IntoStreamer</span>, <span class="ident">Streamer</span>, <span class="ident">Set</span>};
<span class="kw">use</span> <span class="ident">fst_regex</span>::<span class="ident">Regex</span>;

<span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
    <span class="kw">let</span> <span class="ident">set</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[
        <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;foo1&quot;</span>, <span class="string">&quot;foo2&quot;</span>, <span class="string">&quot;foo3&quot;</span>, <span class="string">&quot;foobar&quot;</span>,
    ]).<span class="ident">unwrap</span>();

    <span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex</span>::<span class="ident">new</span>(<span class="string">&quot;f[a-z]+3?&quot;</span>).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">set</span>.<span class="ident">search</span>(<span class="kw-2">&amp;</span><span class="ident">re</span>).<span class="ident">into_stream</span>();

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">keys</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
    <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">key</span>) <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">next</span>() {
        <span class="ident">keys</span>.<span class="ident">push</span>(<span class="ident">key</span>.<span class="ident">to_vec</span>());
    }
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">keys</span>, <span class="macro">vec</span><span class="macro">!</span>[
        <span class="string">&quot;foo&quot;</span>.<span class="ident">as_bytes</span>(), <span class="string">&quot;foo3&quot;</span>.<span class="ident">as_bytes</span>(), <span class="string">&quot;foobar&quot;</span>.<span class="ident">as_bytes</span>(),
    ]);

    <span class="prelude-val">Ok</span>(())
}</pre>
</div><h4 id='method.len' class="method"><span id='len.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#196-198' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the number of elements in this set.</p>
</div><h4 id='method.is_empty' class="method"><span id='is_empty.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#201-203' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns true if and only if this set is empty.</p>
</div><h4 id='method.op' class="method"><span id='op.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.op' class='fnname'>op</a>(&amp;self) -&gt; <a class="struct" href="../fst/set/struct.OpBuilder.html" title="struct fst::set::OpBuilder">OpBuilder</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#227-229' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Creates a new set operation with this set added to it.</p>
<p>The <code>OpBuilder</code> type can be used to add additional set streams
and perform set operations like union, intersection, difference and
symmetric difference.</p>
<h1 id="example-4" class="section-header"><a href="#example-4">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">fst</span>::{<span class="ident">IntoStreamer</span>, <span class="ident">Streamer</span>, <span class="ident">Set</span>};

<span class="kw">let</span> <span class="ident">set1</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">set2</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>]).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">union</span> <span class="op">=</span> <span class="ident">set1</span>.<span class="ident">op</span>().<span class="ident">add</span>(<span class="kw-2">&amp;</span><span class="ident">set2</span>).<span class="ident">union</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">keys</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">key</span>) <span class="op">=</span> <span class="ident">union</span>.<span class="ident">next</span>() {
    <span class="ident">keys</span>.<span class="ident">push</span>(<span class="ident">key</span>.<span class="ident">to_vec</span>());
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">keys</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">b&quot;a&quot;</span>, <span class="string">b&quot;b&quot;</span>, <span class="string">b&quot;c&quot;</span>, <span class="string">b&quot;y&quot;</span>, <span class="string">b&quot;z&quot;</span>]);</pre>
</div><h4 id='method.is_disjoint' class="method"><span id='is_disjoint.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.is_disjoint' class='fnname'>is_disjoint</a>&lt;'f, I, S&gt;(&amp;self, stream: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: for&lt;'a&gt; <a class="trait" href="../fst/trait.IntoStreamer.html" title="trait fst::IntoStreamer">IntoStreamer</a>&lt;'a, Into = S, Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: 'f + for&lt;'a&gt; <a class="trait" href="../fst/trait.Streamer.html" title="trait fst::Streamer">Streamer</a>&lt;'a, Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#250-254' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns true if and only if the <code>self</code> set is disjoint with the set
<code>stream</code>.</p>
<p><code>stream</code> must be a lexicographically ordered sequence of byte strings.</p>
<h1 id="example-5" class="section-header"><a href="#example-5">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">fst</span>::{<span class="ident">IntoStreamer</span>, <span class="ident">Streamer</span>, <span class="ident">Set</span>};

<span class="kw">let</span> <span class="ident">set1</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">set2</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>]).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">set1</span>.<span class="ident">is_disjoint</span>(<span class="kw-2">&amp;</span><span class="ident">set2</span>), <span class="bool-val">true</span>);

<span class="kw">let</span> <span class="ident">set3</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>]).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">set1</span>.<span class="ident">is_disjoint</span>(<span class="kw-2">&amp;</span><span class="ident">set3</span>), <span class="bool-val">false</span>);</pre>
</div><h4 id='method.is_subset' class="method"><span id='is_subset.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.is_subset' class='fnname'>is_subset</a>&lt;'f, I, S&gt;(&amp;self, stream: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: for&lt;'a&gt; <a class="trait" href="../fst/trait.IntoStreamer.html" title="trait fst::IntoStreamer">IntoStreamer</a>&lt;'a, Into = S, Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: 'f + for&lt;'a&gt; <a class="trait" href="../fst/trait.Streamer.html" title="trait fst::Streamer">Streamer</a>&lt;'a, Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#275-279' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns true if and only if the <code>self</code> set is a subset of <code>stream</code>.</p>
<p><code>stream</code> must be a lexicographically ordered sequence of byte strings.</p>
<h1 id="example-6" class="section-header"><a href="#example-6">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">fst</span>::<span class="ident">Set</span>;

<span class="kw">let</span> <span class="ident">set1</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">set2</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>]).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">set1</span>.<span class="ident">is_subset</span>(<span class="kw-2">&amp;</span><span class="ident">set2</span>), <span class="bool-val">false</span>);

<span class="kw">let</span> <span class="ident">set3</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>]).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">set1</span>.<span class="ident">is_subset</span>(<span class="kw-2">&amp;</span><span class="ident">set3</span>), <span class="bool-val">false</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">set3</span>.<span class="ident">is_subset</span>(<span class="kw-2">&amp;</span><span class="ident">set1</span>), <span class="bool-val">true</span>);</pre>
</div><h4 id='method.is_superset' class="method"><span id='is_superset.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.is_superset' class='fnname'>is_superset</a>&lt;'f, I, S&gt;(&amp;self, stream: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: for&lt;'a&gt; <a class="trait" href="../fst/trait.IntoStreamer.html" title="trait fst::IntoStreamer">IntoStreamer</a>&lt;'a, Into = S, Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: 'f + for&lt;'a&gt; <a class="trait" href="../fst/trait.Streamer.html" title="trait fst::Streamer">Streamer</a>&lt;'a, Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#300-304' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns true if and only if the <code>self</code> set is a superset of <code>stream</code>.</p>
<p><code>stream</code> must be a lexicographically ordered sequence of byte strings.</p>
<h1 id="example-7" class="section-header"><a href="#example-7">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">fst</span>::<span class="ident">Set</span>;

<span class="kw">let</span> <span class="ident">set1</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">set2</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>]).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">set1</span>.<span class="ident">is_superset</span>(<span class="kw-2">&amp;</span><span class="ident">set2</span>), <span class="bool-val">false</span>);

<span class="kw">let</span> <span class="ident">set3</span> <span class="op">=</span> <span class="ident">Set</span>::<span class="ident">from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>]).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">set1</span>.<span class="ident">is_superset</span>(<span class="kw-2">&amp;</span><span class="ident">set3</span>), <span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">set3</span>.<span class="ident">is_superset</span>(<span class="kw-2">&amp;</span><span class="ident">set1</span>), <span class="bool-val">false</span>);</pre>
</div><h4 id='method.as_fst' class="method"><span id='as_fst.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.as_fst' class='fnname'>as_fst</a>(&amp;self) -&gt; &amp;<a class="struct" href="../fst/raw/struct.Fst.html" title="struct fst::raw::Fst">Fst</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#307-309' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a reference to the underlying raw finite state transducer.</p>
</div></div>
                <h2 id='implementations' class='small-section-header'>
                  Trait Implementations<a href='#implementations' class='anchor'></a>
                </h2>
                <div id='implementations-list'><h3 id='impl-Debug' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../fst/struct.Set.html" title="struct fst::Set">Set</a></code><a href='#impl-Debug' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#312-326' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.fmt' class="method"><span id='fmt.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#313-325' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-AsRef%3CFst%3E' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../fst/raw/struct.Fst.html" title="struct fst::raw::Fst">Fst</a>&gt; for <a class="struct" href="../fst/struct.Set.html" title="struct fst::Set">Set</a></code><a href='#impl-AsRef%3CFst%3E' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#329-333' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='docblock'><p>Returns the underlying finite state transducer.</p>
</div><div class='impl-items'><h4 id='method.as_ref' class="method"><span id='as_ref.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html#tymethod.as_ref' class='fnname'>as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../fst/raw/struct.Fst.html" title="struct fst::raw::Fst">Fst</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#330-332' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Performs the conversion.</p>
</div></div><h3 id='impl-IntoStreamer%3C%27a%3E' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;'s, 'a&gt; <a class="trait" href="../fst/trait.IntoStreamer.html" title="trait fst::IntoStreamer">IntoStreamer</a>&lt;'a&gt; for &amp;'s <a class="struct" href="../fst/struct.Set.html" title="struct fst::Set">Set</a></code><a href='#impl-IntoStreamer%3C%27a%3E' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#335-342' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='associatedtype.Item' class="type"><span id='Item.t' class='invisible'><code>type <a href='../fst/trait.IntoStreamer.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code></span></h4>
<div class='docblock'><p>The type of the item emitted by the stream.</p>
</div><h4 id='associatedtype.Into' class="type"><span id='Into.t' class='invisible'><code>type <a href='../fst/trait.IntoStreamer.html#associatedtype.Into' class="type">Into</a> = <a class="struct" href="../fst/set/struct.Stream.html" title="struct fst::set::Stream">Stream</a>&lt;'s&gt;</code></span></h4>
<div class='docblock'><p>The type of the stream to be constructed.</p>
</div><h4 id='method.into_stream' class="method"><span id='into_stream.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='../fst/trait.IntoStreamer.html#tymethod.into_stream' class='fnname'>into_stream</a>(self) -&gt; Self::<a class="type" href="../fst/trait.IntoStreamer.html#associatedtype.Into" title="type fst::IntoStreamer::Into">Into</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#339-341' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Construct a stream from <code>Self</code>.</p>
</div></div><h3 id='impl-From%3CFst%3E' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../fst/raw/struct.Fst.html" title="struct fst::raw::Fst">Fst</a>&gt; for <a class="struct" href="../fst/struct.Set.html" title="struct fst::Set">Set</a></code><a href='#impl-From%3CFst%3E' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#345-349' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.from' class="method"><span id='from.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(fst: <a class="struct" href="../fst/raw/struct.Fst.html" title="struct fst::raw::Fst">Fst</a>) -&gt; <a class="struct" href="../fst/struct.Set.html" title="struct fst::Set">Set</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/fst/set.rs.html#346-348' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Performs the conversion.</p>
</div></div></div>
                <h2 id='synthetic-implementations' class='small-section-header'>
                  Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a>
                </h2>
                <div id='synthetic-implementations-list'>
            <h3 id='impl-Send' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../fst/struct.Set.html" title="struct fst::Set">Set</a></code><a href='#impl-Send' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../fst/struct.Set.html" title="struct fst::Set">Set</a></code><a href='#impl-Sync' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt><kbd>?</kbd></dt>
                    <dd>Show this help dialog</dd>
                    <dt><kbd>S</kbd></dt>
                    <dd>Focus the search field</dd>
                    <dt><kbd>↑</kbd></dt>
                    <dd>Move up in search results</dd>
                    <dt><kbd>↓</kbd></dt>
                    <dd>Move down in search results</dd>
                    <dt><kbd>↹</kbd></dt>
                    <dd>Switch tab</dd>
                    <dt><kbd>&#9166;</kbd></dt>
                    <dd>Go to active search result</dd>
                    <dt><kbd>+</kbd></dt>
                    <dd>Expand all sections</dd>
                    <dt><kbd>-</kbd></dt>
                    <dd>Collapse all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "fst";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>