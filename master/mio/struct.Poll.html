<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Poll` struct in crate `mio`."><meta name="keywords" content="rust, rustlang, rust-lang, Poll"><title>mio::Poll - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../mio/index.html'><img src='../rust-logo.png' alt='logo' width='100'></a><p class='location'>Struct Poll</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.deregister">deregister</a><a href="#method.new">new</a><a href="#method.poll">poll</a><a href="#method.poll_interruptible">poll_interruptible</a><a href="#method.register">register</a><a href="#method.reregister">reregister</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-AsRawFd">AsRawFd</a><a href="#impl-Debug">Debug</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow">Borrow</a><a href="#impl-BorrowMut">BorrowMut</a><a href="#impl-From">From</a><a href="#impl-Into">Into</a><a href="#impl-TryFrom">TryFrom</a><a href="#impl-TryInto">TryInto</a></div></div><p class='location'><a href='index.html'>mio</a></p><script>window.sidebarCurrent = {name: 'Poll', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/mio/poll.rs.html#329-345' title='goto source code'>[src]</a></span><span class='in-band'>Struct <a href='index.html'>mio</a>::<wbr><a class="struct" href=''>Poll</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust struct'>pub struct Poll { /* fields omitted */ }</pre></div><div class='docblock'><p>Polls for readiness events on all registered values.</p>
<p><code>Poll</code> allows a program to monitor a large number of <code>Evented</code> types,
waiting until one or more become &quot;ready&quot; for some class of operations; e.g.
reading and writing. An <code>Evented</code> type is considered ready if it is possible
to immediately perform a corresponding operation; e.g. <a href="tcp/struct.TcpStream.html#method.read"><code>read</code></a> or
<a href="tcp/struct.TcpStream.html#method.write"><code>write</code></a>.</p>
<p>To use <code>Poll</code>, an <code>Evented</code> type must first be registered with the <code>Poll</code>
instance using the <a href="#method.register"><code>register</code></a> method, supplying readiness interest. The
readiness interest tells <code>Poll</code> which specific operations on the handle to
monitor for readiness. A <code>Token</code> is also passed to the <a href="#method.register"><code>register</code></a>
function. When <code>Poll</code> returns a readiness event, it will include this token.
This associates the event with the <code>Evented</code> handle that generated the
event.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>A basic example -- establishing a <code>TcpStream</code> connection.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">mio</span>::{<span class="ident">Events</span>, <span class="ident">Poll</span>, <span class="ident">Ready</span>, <span class="ident">PollOpt</span>, <span class="ident">Token</span>};
<span class="kw">use</span> <span class="ident">mio</span>::<span class="ident">net</span>::<span class="ident">TcpStream</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">net</span>::{<span class="ident">TcpListener</span>, <span class="ident">SocketAddr</span>};

<span class="comment">// Bind a server socket to connect to.</span>
<span class="kw">let</span> <span class="ident">addr</span>: <span class="ident">SocketAddr</span> <span class="op">=</span> <span class="string">&quot;127.0.0.1:0&quot;</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">server</span> <span class="op">=</span> <span class="ident">TcpListener</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">addr</span>)<span class="question-mark">?</span>;

<span class="comment">// Construct a new `Poll` handle as well as the `Events` we&#39;ll store into</span>
<span class="kw">let</span> <span class="ident">poll</span> <span class="op">=</span> <span class="ident">Poll</span>::<span class="ident">new</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">events</span> <span class="op">=</span> <span class="ident">Events</span>::<span class="ident">with_capacity</span>(<span class="number">1024</span>);

<span class="comment">// Connect the stream</span>
<span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">TcpStream</span>::<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="ident">server</span>.<span class="ident">local_addr</span>()<span class="question-mark">?</span>)<span class="question-mark">?</span>;

<span class="comment">// Register the stream with `Poll`</span>
<span class="ident">poll</span>.<span class="ident">register</span>(<span class="kw-2">&amp;</span><span class="ident">stream</span>, <span class="ident">Token</span>(<span class="number">0</span>), <span class="ident">Ready</span>::<span class="ident">readable</span>() <span class="op">|</span> <span class="ident">Ready</span>::<span class="ident">writable</span>(), <span class="ident">PollOpt</span>::<span class="ident">edge</span>())<span class="question-mark">?</span>;

<span class="comment">// Wait for the socket to become ready. This has to happens in a loop to</span>
<span class="comment">// handle spurious wakeups.</span>
<span class="kw">loop</span> {
    <span class="ident">poll</span>.<span class="ident">poll</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">events</span>, <span class="prelude-val">None</span>)<span class="question-mark">?</span>;

    <span class="kw">for</span> <span class="ident">event</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">events</span> {
        <span class="kw">if</span> <span class="ident">event</span>.<span class="ident">token</span>() <span class="op">==</span> <span class="ident">Token</span>(<span class="number">0</span>) <span class="op">&amp;&amp;</span> <span class="ident">event</span>.<span class="ident">readiness</span>().<span class="ident">is_writable</span>() {
            <span class="comment">// The socket connected (probably, it could still be a spurious</span>
            <span class="comment">// wakeup)</span>
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(());
        }
    }
}</pre></div>
<h1 id="edge-triggered-and-level-triggered" class="section-header"><a href="#edge-triggered-and-level-triggered">Edge-triggered and level-triggered</a></h1>
<p>An <a href="event/trait.Evented.html"><code>Evented</code></a> registration may request edge-triggered events or
level-triggered events. This is done by setting <code>register</code>'s
<a href="struct.PollOpt.html"><code>PollOpt</code></a> argument to either <a href="struct.PollOpt.html#method.edge"><code>edge</code></a> or <a href="struct.PollOpt.html#method.level"><code>level</code></a>.</p>
<p>The difference between the two can be described as follows. Supposed that
this scenario happens:</p>
<ol>
<li>A <a href="tcp/struct.TcpStream.html"><code>TcpStream</code></a> is registered with <code>Poll</code>.</li>
<li>The socket receives 2kb of data.</li>
<li>A call to <a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a> returns the token associated with the socket
indicating readable readiness.</li>
<li>1kb is read from the socket.</li>
<li>Another call to <a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a> is made.</li>
</ol>
<p>If when the socket was registered with <code>Poll</code>, edge triggered events were
requested, then the call to <a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a> done in step <strong>5</strong> will
(probably) hang despite there being another 1kb still present in the socket
read buffer. The reason for this is that edge-triggered mode delivers events
only when changes occur on the monitored <a href="event/trait.Evented.html"><code>Evented</code></a>. So, in step <em>5</em> the
caller might end up waiting for some data that is already present inside the
socket buffer.</p>
<p>With edge-triggered events, operations <strong>must</strong> be performed on the
<code>Evented</code> type until <a href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html#variant.WouldBlock"><code>WouldBlock</code></a> is returned. In other words, after
receiving an event indicating readiness for a certain operation, one should
assume that <a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a> may never return another event for the same token
and readiness until the operation returns <a href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html#variant.WouldBlock"><code>WouldBlock</code></a>.</p>
<p>By contrast, when level-triggered notifications was requested, each call to
<a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a> will return an event for the socket as long as data remains
in the socket buffer. Generally, level-triggered events should be avoided if
high performance is a concern.</p>
<p>Since even with edge-triggered events, multiple events can be generated upon
receipt of multiple chunks of data, the caller has the option to set the
<a href="struct.PollOpt.html#method.oneshot"><code>oneshot</code></a> flag. This tells <code>Poll</code> to disable the associated <a href="event/trait.Evented.html"><code>Evented</code></a>
after the event is returned from <a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a>. The subsequent calls to
<a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a> will no longer include events for <a href="event/trait.Evented.html"><code>Evented</code></a> handles that
are disabled even if the readiness state changes. The handle can be
re-enabled by calling <a href="#method.reregister"><code>reregister</code></a>. When handles are disabled, internal
resources used to monitor the handle are maintained until the handle is
dropped or deregistered. This makes re-registering the handle a fast
operation.</p>
<p>For example, in the following scenario:</p>
<ol>
<li>A <a href="tcp/struct.TcpStream.html"><code>TcpStream</code></a> is registered with <code>Poll</code>.</li>
<li>The socket receives 2kb of data.</li>
<li>A call to <a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a> returns the token associated with the socket
indicating readable readiness.</li>
<li>2kb is read from the socket.</li>
<li>Another call to read is issued and <a href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html#variant.WouldBlock"><code>WouldBlock</code></a> is returned</li>
<li>The socket receives another 2kb of data.</li>
<li>Another call to <a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a> is made.</li>
</ol>
<p>Assuming the socket was registered with <code>Poll</code> with the <a href="struct.PollOpt.html#method.edge"><code>edge</code></a> and
<a href="struct.PollOpt.html#method.oneshot"><code>oneshot</code></a> options, then the call to <a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a> in step 7 would block. This
is because, <a href="struct.PollOpt.html#method.oneshot"><code>oneshot</code></a> tells <code>Poll</code> to disable events for the socket after
returning an event.</p>
<p>In order to receive the event for the data received in step 6, the socket
would need to be reregistered using <a href="#method.reregister"><code>reregister</code></a>.</p>
<h1 id="portability" class="section-header"><a href="#portability">Portability</a></h1>
<p>Using <code>Poll</code> provides a portable interface across supported platforms as
long as the caller takes the following into consideration:</p>
<h3 id="spurious-events" class="section-header"><a href="#spurious-events">Spurious events</a></h3>
<p><a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a> may return readiness events even if the associated
<a href="event/trait.Evented.html"><code>Evented</code></a> handle is not actually ready. Given the same code, this may
happen more on some platforms than others. It is important to never assume
that, just because a readiness notification was received, that the
associated operation will succeed as well.</p>
<p>If operation fails with <a href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html#variant.WouldBlock"><code>WouldBlock</code></a>, then the caller should not treat
this as an error, but instead should wait until another readiness event is
received.</p>
<h3 id="draining-readiness" class="section-header"><a href="#draining-readiness">Draining readiness</a></h3>
<p>When using edge-triggered mode, once a readiness event is received, the
corresponding operation must be performed repeatedly until it returns
<a href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html#variant.WouldBlock"><code>WouldBlock</code></a>. Unless this is done, there is no guarantee that another
readiness event will be delivered, even if further data is received for the
<a href="event/trait.Evented.html"><code>Evented</code></a> handle.</p>
<p>For example, in the first scenario described above, after step 5, even if
the socket receives more data there is no guarantee that another readiness
event will be delivered.</p>
<h3 id="readiness-operations" class="section-header"><a href="#readiness-operations">Readiness operations</a></h3>
<p>The only readiness operations that are guaranteed to be present on all
supported platforms are <a href="struct.Ready.html#method.readable"><code>readable</code></a> and <a href="struct.Ready.html#method.writable"><code>writable</code></a>. All other readiness
operations may have false negatives and as such should be considered
<strong>hints</strong>. This means that if a socket is registered with <a href="struct.Ready.html#method.readable"><code>readable</code></a>,
<a href="unix/struct.UnixReady.html#method.error"><code>error</code></a>, and <a href="unix/struct.UnixReady.html#method.hup"><code>hup</code></a> interest, and either an error or hup is received, a
readiness event will be generated for the socket, but it <strong>may</strong> only
include <code>readable</code> readiness. Also note that, given the potential for
spurious events, receiving a readiness event with <code>hup</code> or <code>error</code> doesn't
actually mean that a <code>read</code> on the socket will return a result matching the
readiness event.</p>
<p>In other words, portable programs that explicitly check for <a href="unix/struct.UnixReady.html#method.hup"><code>hup</code></a> or
<a href="unix/struct.UnixReady.html#method.error"><code>error</code></a> readiness should be doing so as an <strong>optimization</strong> and always be
able to handle an error or HUP situation when performing the actual read
operation.</p>
<h3 id="registering-handles" class="section-header"><a href="#registering-handles">Registering handles</a></h3>
<p>Unless otherwise noted, it should be assumed that types implementing
<a href="event/trait.Evented.html"><code>Evented</code></a> will never become ready unless they are registered with <code>Poll</code>.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">mio</span>::{<span class="ident">Poll</span>, <span class="ident">Ready</span>, <span class="ident">PollOpt</span>, <span class="ident">Token</span>};
<span class="kw">use</span> <span class="ident">mio</span>::<span class="ident">net</span>::<span class="ident">TcpStream</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;

<span class="kw">let</span> <span class="ident">sock</span> <span class="op">=</span> <span class="ident">TcpStream</span>::<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="string">&quot;216.58.193.100:80&quot;</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>)<span class="question-mark">?</span>;

<span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">Duration</span>::<span class="ident">from_secs</span>(<span class="number">1</span>));

<span class="kw">let</span> <span class="ident">poll</span> <span class="op">=</span> <span class="ident">Poll</span>::<span class="ident">new</span>()<span class="question-mark">?</span>;

<span class="comment">// The connect is not guaranteed to have started until it is registered at</span>
<span class="comment">// this point</span>
<span class="ident">poll</span>.<span class="ident">register</span>(<span class="kw-2">&amp;</span><span class="ident">sock</span>, <span class="ident">Token</span>(<span class="number">0</span>), <span class="ident">Ready</span>::<span class="ident">readable</span>() <span class="op">|</span> <span class="ident">Ready</span>::<span class="ident">writable</span>(), <span class="ident">PollOpt</span>::<span class="ident">edge</span>())<span class="question-mark">?</span>;</pre></div>
<h1 id="implementation-notes" class="section-header"><a href="#implementation-notes">Implementation notes</a></h1>
<p><code>Poll</code> is backed by the selector provided by the operating system.</p>
<table><thead><tr><th>      OS    </th><th>  Selector </th></tr></thead><tbody>
<tr><td> Linux      </td><td> <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a>   </td></tr>
<tr><td> OS X, iOS  </td><td> <a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2">kqueue</a>  </td></tr>
<tr><td> Windows    </td><td> <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198(v=vs.85).aspx">IOCP</a>    </td></tr>
<tr><td> FreeBSD    </td><td> <a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2">kqueue</a>  </td></tr>
<tr><td> Android    </td><td> <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a>   </td></tr>
</tbody></table>
<p>On all supported platforms, socket operations are handled by using the
system selector. Platform specific extensions (e.g. <a href="unix/struct.EventedFd.html"><code>EventedFd</code></a>) allow
accessing other features provided by individual system selectors. For
example, Linux's <a href="http://man7.org/linux/man-pages/man2/signalfd.2.html"><code>signalfd</code></a> feature can be used by registering the FD with
<code>Poll</code> via <a href="unix/struct.EventedFd.html"><code>EventedFd</code></a>.</p>
<p>On all platforms except windows, a call to <a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a> is mostly just a
direct call to the system selector. However, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198(v=vs.85).aspx">IOCP</a> uses a completion model
instead of a readiness model. In this case, <code>Poll</code> must adapt the completion
model Mio's API. While non-trivial, the bridge layer is still quite
efficient. The most expensive part being calls to <code>read</code> and <code>write</code> require
data to be copied into an intermediate buffer before it is passed to the
kernel.</p>
<p>Notifications generated by <a href="struct.SetReadiness.html"><code>SetReadiness</code></a> are handled by an internal
readiness queue. A single call to <a href="struct.Poll.html#method.poll"><code>Poll::poll</code></a> will collect events from
both from the system selector and the internal readiness queue.</p>
</div><h2 id='methods' class='small-section-header'>Methods<a href='#methods' class='anchor'></a></h2><h3 id='impl' class='impl'><code class='in-band'>impl <a class="struct" href="../mio/struct.Poll.html" title="struct mio::Poll">Poll</a></code><a href='#impl' class='anchor'></a><a class='srclink' href='../src/mio/poll.rs.html#614-1207' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.new' class="method"><code id='new.v'>pub fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../mio/struct.Poll.html" title="struct mio::Poll">Poll</a>&gt;</code><a class='srclink' href='../src/mio/poll.rs.html#652-668' title='goto source code'>[src]</a></h4><div class='docblock'><p>Return a new <code>Poll</code> handle.</p>
<p>This function will make a syscall to the operating system to create the
system selector. If this syscall fails, <code>Poll::new</code> will return with the
error.</p>
<p>See <a href="struct.Poll.html">struct</a> level docs for more details.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">mio</span>::{<span class="ident">Poll</span>, <span class="ident">Events</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;

<span class="kw">let</span> <span class="ident">poll</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">Poll</span>::<span class="ident">new</span>() {
    <span class="prelude-val">Ok</span>(<span class="ident">poll</span>) <span class="op">=&gt;</span> <span class="ident">poll</span>,
    <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=&gt;</span> <span class="macro">panic</span><span class="macro">!</span>(<span class="string">&quot;failed to create Poll instance; err={:?}&quot;</span>, <span class="ident">e</span>),
};

<span class="comment">// Create a structure to receive polled events</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">events</span> <span class="op">=</span> <span class="ident">Events</span>::<span class="ident">with_capacity</span>(<span class="number">1024</span>);

<span class="comment">// Wait for events, but none will be received because no `Evented`</span>
<span class="comment">// handles have been registered with this `Poll` instance.</span>
<span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">poll</span>.<span class="ident">poll</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">events</span>, <span class="prelude-val">Some</span>(<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">500</span>)))<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">n</span>, <span class="number">0</span>);</pre></div>
</div><h4 id='method.register' class="method"><code id='register.v'>pub fn <a href='#method.register' class='fnname'>register</a>&lt;E:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;handle: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>E, <br>&nbsp;&nbsp;&nbsp;&nbsp;token: <a class="struct" href="../mio/struct.Token.html" title="struct mio::Token">Token</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;interest: <a class="struct" href="../mio/struct.Ready.html" title="struct mio::Ready">Ready</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opts: <a class="struct" href="../mio/struct.PollOpt.html" title="struct mio::PollOpt">PollOpt</a><br>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;E: <a class="trait" href="../mio/event/trait.Evented.html" title="trait mio::event::Evented">Evented</a>,&nbsp;</span></code><a class='srclink' href='../src/mio/poll.rs.html#777-793' title='goto source code'>[src]</a></h4><div class='docblock'><p>Register an <code>Evented</code> handle with the <code>Poll</code> instance.</p>
<p>Once registered, the <code>Poll</code> instance will monitor the <code>Evented</code> handle
for readiness state changes. When it notices a state change, it will
return a readiness event for the handle the next time <a href="#method.poll"><code>poll</code></a> is
called.</p>
<p>See the <a href="#"><code>struct</code></a> docs for a high level overview.</p>
<h1 id="arguments" class="section-header"><a href="#arguments">Arguments</a></h1>
<p><code>handle: &amp;E: Evented</code>: This is the handle that the <code>Poll</code> instance
should monitor for readiness state changes.</p>
<p><code>token: Token</code>: The caller picks a token to associate with the socket.
When <a href="#method.poll"><code>poll</code></a> returns an event for the handle, this token is included.
This allows the caller to map the event to its handle. The token
associated with the <code>Evented</code> handle can be changed at any time by
calling <a href="#method.reregister"><code>reregister</code></a>.</p>
<p><code>token</code> cannot be <code>Token(usize::MAX)</code> as it is reserved for internal
usage.</p>
<p>See documentation on <a href="struct.Token.html"><code>Token</code></a> for an example showing how to pick
<a href="struct.Token.html"><code>Token</code></a> values.</p>
<p><code>interest: Ready</code>: Specifies which operations <code>Poll</code> should monitor for
readiness. <code>Poll</code> will only return readiness events for operations
specified by this argument.</p>
<p>If a socket is registered with readable interest and the socket becomes
writable, no event will be returned from <a href="#method.poll"><code>poll</code></a>.</p>
<p>The readiness interest for an <code>Evented</code> handle can be changed at any
time by calling <a href="#method.reregister"><code>reregister</code></a>.</p>
<p><code>opts: PollOpt</code>: Specifies the registration options. The most common
options being <a href="struct.PollOpt.html#method.level"><code>level</code></a> for level-triggered events, <a href="struct.PollOpt.html#method.edge"><code>edge</code></a> for
edge-triggered events, and <a href="struct.PollOpt.html#method.oneshot"><code>oneshot</code></a>.</p>
<p>The registration options for an <code>Evented</code> handle can be changed at any
time by calling <a href="#method.reregister"><code>reregister</code></a>.</p>
<h1 id="notes" class="section-header"><a href="#notes">Notes</a></h1>
<p>Unless otherwise specified, the caller should assume that once an
<code>Evented</code> handle is registered with a <code>Poll</code> instance, it is bound to
that <code>Poll</code> instance for the lifetime of the <code>Evented</code> handle. This
remains true even if the <code>Evented</code> handle is deregistered from the poll
instance using <a href="#method.deregister"><code>deregister</code></a>.</p>
<p>This function is <strong>thread safe</strong>. It can be called concurrently from
multiple threads.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">mio</span>::{<span class="ident">Events</span>, <span class="ident">Poll</span>, <span class="ident">Ready</span>, <span class="ident">PollOpt</span>, <span class="ident">Token</span>};
<span class="kw">use</span> <span class="ident">mio</span>::<span class="ident">net</span>::<span class="ident">TcpStream</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::{<span class="ident">Duration</span>, <span class="ident">Instant</span>};

<span class="kw">let</span> <span class="ident">poll</span> <span class="op">=</span> <span class="ident">Poll</span>::<span class="ident">new</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">TcpStream</span>::<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="string">&quot;216.58.193.100:80&quot;</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>)<span class="question-mark">?</span>;

<span class="comment">// Register the socket with `poll`</span>
<span class="ident">poll</span>.<span class="ident">register</span>(<span class="kw-2">&amp;</span><span class="ident">socket</span>, <span class="ident">Token</span>(<span class="number">0</span>), <span class="ident">Ready</span>::<span class="ident">readable</span>() <span class="op">|</span> <span class="ident">Ready</span>::<span class="ident">writable</span>(), <span class="ident">PollOpt</span>::<span class="ident">edge</span>())<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">events</span> <span class="op">=</span> <span class="ident">Events</span>::<span class="ident">with_capacity</span>(<span class="number">1024</span>);
<span class="kw">let</span> <span class="ident">start</span> <span class="op">=</span> <span class="ident">Instant</span>::<span class="ident">now</span>();
<span class="kw">let</span> <span class="ident">timeout</span> <span class="op">=</span> <span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">500</span>);

<span class="kw">loop</span> {
    <span class="kw">let</span> <span class="ident">elapsed</span> <span class="op">=</span> <span class="ident">start</span>.<span class="ident">elapsed</span>();

    <span class="kw">if</span> <span class="ident">elapsed</span> <span class="op">&gt;=</span> <span class="ident">timeout</span> {
        <span class="comment">// Connection timed out</span>
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(());
    }

    <span class="kw">let</span> <span class="ident">remaining</span> <span class="op">=</span> <span class="ident">timeout</span> <span class="op">-</span> <span class="ident">elapsed</span>;
    <span class="ident">poll</span>.<span class="ident">poll</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">events</span>, <span class="prelude-val">Some</span>(<span class="ident">remaining</span>))<span class="question-mark">?</span>;

    <span class="kw">for</span> <span class="ident">event</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">events</span> {
        <span class="kw">if</span> <span class="ident">event</span>.<span class="ident">token</span>() <span class="op">==</span> <span class="ident">Token</span>(<span class="number">0</span>) {
            <span class="comment">// Something (probably) happened on the socket.</span>
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(());
        }
    }
}</pre></div>
</div><h4 id='method.reregister' class="method"><code id='reregister.v'>pub fn <a href='#method.reregister' class='fnname'>reregister</a>&lt;E:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;handle: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>E, <br>&nbsp;&nbsp;&nbsp;&nbsp;token: <a class="struct" href="../mio/struct.Token.html" title="struct mio::Token">Token</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;interest: <a class="struct" href="../mio/struct.Ready.html" title="struct mio::Ready">Ready</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opts: <a class="struct" href="../mio/struct.PollOpt.html" title="struct mio::PollOpt">PollOpt</a><br>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;E: <a class="trait" href="../mio/event/trait.Evented.html" title="trait mio::event::Evented">Evented</a>,&nbsp;</span></code><a class='srclink' href='../src/mio/poll.rs.html#848-859' title='goto source code'>[src]</a></h4><div class='docblock'><p>Re-register an <code>Evented</code> handle with the <code>Poll</code> instance.</p>
<p>Re-registering an <code>Evented</code> handle allows changing the details of the
registration. Specifically, it allows updating the associated <code>token</code>,
<code>interest</code>, and <code>opts</code> specified in previous <code>register</code> and <code>reregister</code>
calls.</p>
<p>The <code>reregister</code> arguments fully override the previous values. In other
words, if a socket is registered with <a href="struct.Ready.html#method.readable"><code>readable</code></a> interest and the call
to <code>reregister</code> specifies <a href="struct.Ready.html#method.writable"><code>writable</code></a>, then read interest is no longer
requested for the handle.</p>
<p>The <code>Evented</code> handle must have previously been registered with this
instance of <code>Poll</code> otherwise the call to <code>reregister</code> will return with
an error.</p>
<p><code>token</code> cannot be <code>Token(usize::MAX)</code> as it is reserved for internal
usage.</p>
<p>See the <a href="#method.register"><code>register</code></a> documentation for details about the function
arguments and see the <a href="#"><code>struct</code></a> docs for a high level overview of
polling.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">mio</span>::{<span class="ident">Poll</span>, <span class="ident">Ready</span>, <span class="ident">PollOpt</span>, <span class="ident">Token</span>};
<span class="kw">use</span> <span class="ident">mio</span>::<span class="ident">net</span>::<span class="ident">TcpStream</span>;

<span class="kw">let</span> <span class="ident">poll</span> <span class="op">=</span> <span class="ident">Poll</span>::<span class="ident">new</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">TcpStream</span>::<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="string">&quot;216.58.193.100:80&quot;</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>)<span class="question-mark">?</span>;

<span class="comment">// Register the socket with `poll`, requesting readable</span>
<span class="ident">poll</span>.<span class="ident">register</span>(<span class="kw-2">&amp;</span><span class="ident">socket</span>, <span class="ident">Token</span>(<span class="number">0</span>), <span class="ident">Ready</span>::<span class="ident">readable</span>(), <span class="ident">PollOpt</span>::<span class="ident">edge</span>())<span class="question-mark">?</span>;

<span class="comment">// Reregister the socket specifying a different token and write interest</span>
<span class="comment">// instead. `PollOpt::edge()` must be specified even though that value</span>
<span class="comment">// is not being changed.</span>
<span class="ident">poll</span>.<span class="ident">reregister</span>(<span class="kw-2">&amp;</span><span class="ident">socket</span>, <span class="ident">Token</span>(<span class="number">2</span>), <span class="ident">Ready</span>::<span class="ident">writable</span>(), <span class="ident">PollOpt</span>::<span class="ident">edge</span>())<span class="question-mark">?</span>;</pre></div>
</div><h4 id='method.deregister' class="method"><code id='deregister.v'>pub fn <a href='#method.deregister' class='fnname'>deregister</a>&lt;E:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(&amp;self, handle: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>E) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;E: <a class="trait" href="../mio/event/trait.Evented.html" title="trait mio::event::Evented">Evented</a>,&nbsp;</span></code><a class='srclink' href='../src/mio/poll.rs.html#904-913' title='goto source code'>[src]</a></h4><div class='docblock'><p>Deregister an <code>Evented</code> handle with the <code>Poll</code> instance.</p>
<p>When an <code>Evented</code> handle is deregistered, the <code>Poll</code> instance will
no longer monitor it for readiness state changes. Unlike disabling
handles with oneshot, deregistering clears up any internal resources
needed to track the handle.</p>
<p>A handle can be passed back to <code>register</code> after it has been
deregistered; however, it must be passed back to the <strong>same</strong> <code>Poll</code>
instance.</p>
<p><code>Evented</code> handles are automatically deregistered when they are dropped.
It is common to never need to explicitly call <code>deregister</code>.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">mio</span>::{<span class="ident">Events</span>, <span class="ident">Poll</span>, <span class="ident">Ready</span>, <span class="ident">PollOpt</span>, <span class="ident">Token</span>};
<span class="kw">use</span> <span class="ident">mio</span>::<span class="ident">net</span>::<span class="ident">TcpStream</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;

<span class="kw">let</span> <span class="ident">poll</span> <span class="op">=</span> <span class="ident">Poll</span>::<span class="ident">new</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">TcpStream</span>::<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="string">&quot;216.58.193.100:80&quot;</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>)<span class="question-mark">?</span>;

<span class="comment">// Register the socket with `poll`</span>
<span class="ident">poll</span>.<span class="ident">register</span>(<span class="kw-2">&amp;</span><span class="ident">socket</span>, <span class="ident">Token</span>(<span class="number">0</span>), <span class="ident">Ready</span>::<span class="ident">readable</span>(), <span class="ident">PollOpt</span>::<span class="ident">edge</span>())<span class="question-mark">?</span>;

<span class="ident">poll</span>.<span class="ident">deregister</span>(<span class="kw-2">&amp;</span><span class="ident">socket</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">events</span> <span class="op">=</span> <span class="ident">Events</span>::<span class="ident">with_capacity</span>(<span class="number">1024</span>);

<span class="comment">// Set a timeout because this poll should never receive any events.</span>
<span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">poll</span>.<span class="ident">poll</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">events</span>, <span class="prelude-val">Some</span>(<span class="ident">Duration</span>::<span class="ident">from_secs</span>(<span class="number">1</span>)))<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0</span>, <span class="ident">n</span>);</pre></div>
</div><h4 id='method.poll' class="method"><code id='poll.v'>pub fn <a href='#method.poll' class='fnname'>poll</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;events: &amp;mut <a class="struct" href="../mio/struct.Events.html" title="struct mio::Events">Events</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;timeout: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt;<br>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class='srclink' href='../src/mio/poll.rs.html#1009-1011' title='goto source code'>[src]</a></h4><div class='docblock'><p>Wait for readiness events</p>
<p>Blocks the current thread and waits for readiness events for any of the
<code>Evented</code> handles that have been registered with this <code>Poll</code> instance.
The function will block until either at least one readiness event has
been received or <code>timeout</code> has elapsed. A <code>timeout</code> of <code>None</code> means that
<code>poll</code> will block until a readiness event has been received.</p>
<p>The supplied <code>events</code> will be cleared and newly received readiness events
will be pushed onto the end. At most <code>events.capacity()</code> events will be
returned. If there are further pending readiness events, they will be
returned on the next call to <code>poll</code>.</p>
<p>A single call to <code>poll</code> may result in multiple readiness events being
returned for a single <code>Evented</code> handle. For example, if a TCP socket
becomes both readable and writable, it may be possible for a single
readiness event to be returned with both <a href="struct.Ready.html#method.readable"><code>readable</code></a> and <a href="struct.Ready.html#method.writable"><code>writable</code></a>
readiness <strong>OR</strong> two separate events may be returned, one with
<a href="struct.Ready.html#method.readable"><code>readable</code></a> set and one with <a href="struct.Ready.html#method.writable"><code>writable</code></a> set.</p>
<p>Note that the <code>timeout</code> will be rounded up to the system clock
granularity (usually 1ms), and kernel scheduling delays mean that
the blocking interval may be overrun by a small amount.</p>
<p><code>poll</code> returns the number of readiness events that have been pushed into
<code>events</code> or <code>Err</code> when an error has been encountered with the system
selector.  The value returned is deprecated and will be removed in 0.7.0.
Accessing the events by index is also deprecated.  Events can be
inserted by other events triggering, thus making sequential access
problematic.  Use the iterator API instead.  See <a href="struct.Events.html#method.iter"><code>iter</code></a>.</p>
<p>See the <a href="#">struct</a> level documentation for a higher level discussion of
polling.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<p>A basic example -- establishing a <code>TcpStream</code> connection.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">mio</span>::{<span class="ident">Events</span>, <span class="ident">Poll</span>, <span class="ident">Ready</span>, <span class="ident">PollOpt</span>, <span class="ident">Token</span>};
<span class="kw">use</span> <span class="ident">mio</span>::<span class="ident">net</span>::<span class="ident">TcpStream</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">net</span>::{<span class="ident">TcpListener</span>, <span class="ident">SocketAddr</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;

<span class="comment">// Bind a server socket to connect to.</span>
<span class="kw">let</span> <span class="ident">addr</span>: <span class="ident">SocketAddr</span> <span class="op">=</span> <span class="string">&quot;127.0.0.1:0&quot;</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">server</span> <span class="op">=</span> <span class="ident">TcpListener</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">addr</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">addr</span> <span class="op">=</span> <span class="ident">server</span>.<span class="ident">local_addr</span>()<span class="question-mark">?</span>.<span class="ident">clone</span>();

<span class="comment">// Spawn a thread to accept the socket</span>
<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> {
    <span class="kw">let</span> <span class="kw">_</span> <span class="op">=</span> <span class="ident">server</span>.<span class="ident">accept</span>();
});

<span class="comment">// Construct a new `Poll` handle as well as the `Events` we&#39;ll store into</span>
<span class="kw">let</span> <span class="ident">poll</span> <span class="op">=</span> <span class="ident">Poll</span>::<span class="ident">new</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">events</span> <span class="op">=</span> <span class="ident">Events</span>::<span class="ident">with_capacity</span>(<span class="number">1024</span>);

<span class="comment">// Connect the stream</span>
<span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">TcpStream</span>::<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="ident">addr</span>)<span class="question-mark">?</span>;

<span class="comment">// Register the stream with `Poll`</span>
<span class="ident">poll</span>.<span class="ident">register</span>(<span class="kw-2">&amp;</span><span class="ident">stream</span>, <span class="ident">Token</span>(<span class="number">0</span>), <span class="ident">Ready</span>::<span class="ident">readable</span>() <span class="op">|</span> <span class="ident">Ready</span>::<span class="ident">writable</span>(), <span class="ident">PollOpt</span>::<span class="ident">edge</span>())<span class="question-mark">?</span>;

<span class="comment">// Wait for the socket to become ready. This has to happens in a loop to</span>
<span class="comment">// handle spurious wakeups.</span>
<span class="kw">loop</span> {
    <span class="ident">poll</span>.<span class="ident">poll</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">events</span>, <span class="prelude-val">None</span>)<span class="question-mark">?</span>;

    <span class="kw">for</span> <span class="ident">event</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">events</span> {
        <span class="kw">if</span> <span class="ident">event</span>.<span class="ident">token</span>() <span class="op">==</span> <span class="ident">Token</span>(<span class="number">0</span>) <span class="op">&amp;&amp;</span> <span class="ident">event</span>.<span class="ident">readiness</span>().<span class="ident">is_writable</span>() {
            <span class="comment">// The socket connected (probably, it could still be a spurious</span>
            <span class="comment">// wakeup)</span>
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(());
        }
    }
}</pre></div>
</div><h4 id='method.poll_interruptible' class="method"><code id='poll_interruptible.v'>pub fn <a href='#method.poll_interruptible' class='fnname'>poll_interruptible</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;events: &amp;mut <a class="struct" href="../mio/struct.Events.html" title="struct mio::Events">Events</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;timeout: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt;<br>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class='srclink' href='../src/mio/poll.rs.html#1017-1019' title='goto source code'>[src]</a></h4><div class='docblock'><p>Like <code>poll</code>, but may be interrupted by a signal</p>
<p>If <code>poll</code> is inturrupted while blocking, it will transparently retry the syscall.  If you
want to handle signals yourself, however, use <code>poll_interruptible</code>.</p>
</div></div><h2 id='implementations' class='small-section-header'>Trait Implementations<a href='#implementations' class='anchor'></a></h2><div id='implementations-list'><h3 id='impl-Debug' class='impl'><code class='in-band'>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../mio/struct.Poll.html" title="struct mio::Poll">Poll</a></code><a href='#impl-Debug' class='anchor'></a><a class='srclink' href='../src/mio/poll.rs.html#1217-1222' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt' class="method hidden"><code id='fmt.v'>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class='srclink' href='../src/mio/poll.rs.html#1218-1221' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-AsRawFd' class='impl'><code class='in-band'>impl <a class="trait" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/trait.AsRawFd.html" title="trait std::sys::unix::ext::io::AsRawFd">AsRawFd</a> for <a class="struct" href="../mio/struct.Poll.html" title="struct mio::Poll">Poll</a></code><a href='#impl-AsRawFd' class='anchor'></a><a class='srclink' href='../src/mio/poll.rs.html#1225-1229' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.as_raw_fd' class="method hidden"><code id='as_raw_fd.v'>fn <a href='https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/trait.AsRawFd.html#tymethod.as_raw_fd' class='fnname'>as_raw_fd</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a></code><a class='srclink' href='../src/mio/poll.rs.html#1226-1228' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Extracts the raw file descriptor. <a href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/trait.AsRawFd.html#tymethod.as_raw_fd">Read more</a></p>
</div></div></div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-Send' class='impl'><code class='in-band'>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../mio/struct.Poll.html" title="struct mio::Poll">Poll</a></code><a href='#impl-Send' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><code class='in-band'>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../mio/struct.Poll.html" title="struct mio::Poll">Poll</a></code><a href='#impl-Sync' class='anchor'></a></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-From' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a> for T</code><a href='#impl-From' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#546-548' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><code id='from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#547' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#537-542' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><code id='into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#539-541' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryFrom' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryFrom' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#565-571' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><code id='Error.t'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method hidden"><code id='try_from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#568-570' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Borrow' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#213-215' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow' class="method hidden"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>R</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>R</h3><code class="content"><span class="where fmt-newline">impl&lt;'_, R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;'_, W&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>W <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;W: <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></span></code></div></div><code id='borrow.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-Any' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#100-102' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.type_id' class="method hidden"><code id='type_id.v'>fn <a href='https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id' class='fnname'>type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#101' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id='impl-BorrowMut' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218-220' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow_mut' class="method hidden"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>R</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>R</h3><code class="content"><span class="where fmt-newline">impl&lt;'_, R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;'_, W&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>W <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;W: <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></span></code></div></div><code id='borrow_mut.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#219' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-TryInto' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#553-560' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><code id='Error.t-1'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method hidden"><code id='try_into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#557-559' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "mio";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>