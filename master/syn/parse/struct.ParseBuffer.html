<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `ParseBuffer` struct in crate `syn`."><meta name="keywords" content="rust, rustlang, rust-lang, ParseBuffer"><title>syn::parse::ParseBuffer - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../syn/index.html'><img src='../../rust-logo.png' alt='logo' width='100'></a><p class='location'>Struct ParseBuffer</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.call">call</a><a href="#method.cursor">cursor</a><a href="#method.error">error</a><a href="#method.fork">fork</a><a href="#method.is_empty">is_empty</a><a href="#method.lookahead1">lookahead1</a><a href="#method.parse">parse</a><a href="#method.parse_terminated">parse_terminated</a><a href="#method.peek">peek</a><a href="#method.peek2">peek2</a><a href="#method.peek3">peek3</a><a href="#method.step">step</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Debug">Debug</a><a href="#impl-Display">Display</a><a href="#impl-Drop">Drop</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow">Borrow</a><a href="#impl-BorrowMut">BorrowMut</a><a href="#impl-From">From</a><a href="#impl-Into">Into</a><a href="#impl-ToString">ToString</a><a href="#impl-TryFrom">TryFrom</a><a href="#impl-TryInto">TryInto</a></div></div><p class='location'><a href='../index.html'>syn</a>::<wbr><a href='index.html'>parse</a></p><script>window.sidebarCurrent = {name: 'ParseBuffer', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/syn/parse.rs.html#250-266' title='goto source code'>[src]</a></span><span class='in-band'>Struct <a href='../index.html'>syn</a>::<wbr><a href='index.html'>parse</a>::<wbr><a class="struct" href=''>ParseBuffer</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust struct'>pub struct ParseBuffer&lt;'a&gt; { /* fields omitted */ }</pre></div><div class='docblock'><p>Cursor position within a buffered token stream.</p>
<p>This type is more commonly used through the type alias [<code>ParseStream</code>] which
is an alias for <code>&amp;ParseBuffer</code>.</p>
<p><code>ParseStream</code> is the input type for all parser functions in Syn. They have
the signature <code>fn(ParseStream) -&gt; Result&lt;T&gt;</code>.</p>
<h2 id="calling-a-parser-function" class="section-header"><a href="#calling-a-parser-function">Calling a parser function</a></h2>
<p>There is no public way to construct a <code>ParseBuffer</code>. Instead, if you are
looking to invoke a parser function that requires <code>ParseStream</code> as input,
you will need to go through one of the public parsing entry points.</p>
<ul>
<li>The <a href="../macro.parse_macro_input.html"><code>parse_macro_input!</code></a> macro if parsing input of a procedural macro;</li>
<li>One of <a href="index.html#the-synparse-functions">the <code>syn::parse*</code> functions</a>; or</li>
<li>A method of the [<code>Parser</code>] trait.</li>
</ul>
</div><h2 id='methods' class='small-section-header'>Methods<a href='#methods' class='anchor'></a></h2><h3 id='impl' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="struct" href="../../syn/parse/struct.ParseBuffer.html" title="struct syn::parse::ParseBuffer">ParseBuffer</a>&lt;'a&gt;</code><a href='#impl' class='anchor'></a><a class='srclink' href='../../src/syn/parse.rs.html#413-976' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.parse' class="method"><code id='parse.v'>pub fn <a href='#method.parse' class='fnname'>parse</a>&lt;T:&nbsp;<a class="trait" href="../../syn/parse/trait.Parse.html" title="trait syn::parse::Parse">Parse</a>&gt;(&amp;self) -&gt; <a class="type" href="../../syn/parse/type.Result.html" title="type syn::parse::Result">Result</a>&lt;T&gt;</code><a class='srclink' href='../../src/syn/parse.rs.html#416-418' title='goto source code'>[src]</a></h4><div class='docblock'><p>Parses a syntax tree node of type <code>T</code>, advancing the position of our
parse stream past it.</p>
</div><h4 id='method.call' class="method"><code id='call.v'>pub fn <a href='#method.call' class='fnname'>call</a>&lt;T&gt;(&amp;self, function: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.fn.html">fn</a>(_: <a class="type" href="../../syn/parse/type.ParseStream.html" title="type syn::parse::ParseStream">ParseStream</a>) -&gt; <a class="type" href="../../syn/parse/type.Result.html" title="type syn::parse::Result">Result</a>&lt;T&gt;) -&gt; <a class="type" href="../../syn/parse/type.Result.html" title="type syn::parse::Result">Result</a>&lt;T&gt;</code><a class='srclink' href='../../src/syn/parse.rs.html#456-458' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calls the given parser function to parse a syntax tree node of type <code>T</code>
from this stream.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<p>The parser below invokes <a href="../struct.Attribute.html#method.parse_outer"><code>Attribute::parse_outer</code></a> to parse a vector of
zero or more outer attributes.</p>
<pre><code class="language-edition2018">use syn::{Attribute, Ident, Result, Token};
use syn::parse::{Parse, ParseStream};

// Parses a unit struct with attributes.
//
//     #[path = &quot;s.tmpl&quot;]
//     struct S;
struct UnitStruct {
    attrs: Vec&lt;Attribute&gt;,
    struct_token: Token![struct],
    name: Ident,
    semi_token: Token![;],
}

impl Parse for UnitStruct {
    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {
        Ok(UnitStruct {
            attrs: input.call(Attribute::parse_outer)?,
            struct_token: input.parse()?,
            name: input.parse()?,
            semi_token: input.parse()?,
        })
    }
}
</code></pre>
</div><h4 id='method.peek' class="method"><code id='peek.v'>pub fn <a href='#method.peek' class='fnname'>peek</a>&lt;T:&nbsp;<a class="trait" href="../../syn/parse/trait.Peek.html" title="trait syn::parse::Peek">Peek</a>&gt;(&amp;self, token: T) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/syn/parse.rs.html#532-535' title='goto source code'>[src]</a></h4><div class='docblock'><p>Looks at the next token in the parse stream to determine whether it
matches the requested type of token.</p>
<p>Does not advance the position of the parse stream.</p>
<h1 id="syntax" class="section-header"><a href="#syntax">Syntax</a></h1>
<p>Note that this method does not use turbofish syntax. Pass the peek type
inside of parentheses.</p>
<ul>
<li><code>input.peek(Token![struct])</code></li>
<li><code>input.peek(Token![==])</code></li>
<li><code>input.peek(Ident)</code> <em>(does not accept keywords)</em></li>
<li><code>input.peek(Ident::peek_any)</code></li>
<li><code>input.peek(Lifetime)</code></li>
<li><code>input.peek(token::Brace)</code></li>
</ul>
<h1 id="example-1" class="section-header"><a href="#example-1">Example</a></h1>
<p>In this example we finish parsing the list of supertraits when the next
token in the input is either <code>where</code> or an opening curly brace.</p>
<pre><code class="language-edition2018">use syn::{braced, token, Generics, Ident, Result, Token, TypeParamBound};
use syn::parse::{Parse, ParseStream};
use syn::punctuated::Punctuated;

// Parses a trait definition containing no associated items.
//
//     trait Marker&lt;'de, T&gt;: A + B&lt;'de&gt; where Box&lt;T&gt;: Clone {}
struct MarkerTrait {
    trait_token: Token![trait],
    ident: Ident,
    generics: Generics,
    colon_token: Option&lt;Token![:]&gt;,
    supertraits: Punctuated&lt;TypeParamBound, Token![+]&gt;,
    brace_token: token::Brace,
}

impl Parse for MarkerTrait {
    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {
        let trait_token: Token![trait] = input.parse()?;
        let ident: Ident = input.parse()?;
        let mut generics: Generics = input.parse()?;
        let colon_token: Option&lt;Token![:]&gt; = input.parse()?;

        let mut supertraits = Punctuated::new();
        if colon_token.is_some() {
            loop {
                supertraits.push_value(input.parse()?);
                if input.peek(Token![where]) || input.peek(token::Brace) {
                    break;
                }
                supertraits.push_punct(input.parse()?);
            }
        }

        generics.where_clause = input.parse()?;
        let content;
        let empty_brace_token = braced!(content in input);

        Ok(MarkerTrait {
            trait_token: trait_token,
            ident: ident,
            generics: generics,
            colon_token: colon_token,
            supertraits: supertraits,
            brace_token: empty_brace_token,
        })
    }
}
</code></pre>
</div><h4 id='method.peek2' class="method"><code id='peek2.v'>pub fn <a href='#method.peek2' class='fnname'>peek2</a>&lt;T:&nbsp;<a class="trait" href="../../syn/parse/trait.Peek.html" title="trait syn::parse::Peek">Peek</a>&gt;(&amp;self, token: T) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/syn/parse.rs.html#571-574' title='goto source code'>[src]</a></h4><div class='docblock'><p>Looks at the second-next token in the parse stream.</p>
<p>This is commonly useful as a way to implement contextual keywords.</p>
<h1 id="example-2" class="section-header"><a href="#example-2">Example</a></h1>
<p>This example needs to use <code>peek2</code> because the symbol <code>union</code> is not a
keyword in Rust. We can't use just <code>peek</code> and decide to parse a union if
the very next token is <code>union</code>, because someone is free to write a <code>mod union</code> and a macro invocation that looks like <code>union::some_macro! { ... }</code>. In other words <code>union</code> is a contextual keyword.</p>
<pre><code class="language-edition2018">use syn::{Ident, ItemUnion, Macro, Result, Token};
use syn::parse::{Parse, ParseStream};

// Parses either a union or a macro invocation.
enum UnionOrMacro {
    // union MaybeUninit&lt;T&gt; { uninit: (), value: T }
    Union(ItemUnion),
    // lazy_static! { ... }
    Macro(Macro),
}

impl Parse for UnionOrMacro {
    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {
        if input.peek(Token![union]) &amp;&amp; input.peek2(Ident) {
            input.parse().map(UnionOrMacro::Union)
        } else {
            input.parse().map(UnionOrMacro::Macro)
        }
    }
}
</code></pre>
</div><h4 id='method.peek3' class="method"><code id='peek3.v'>pub fn <a href='#method.peek3' class='fnname'>peek3</a>&lt;T:&nbsp;<a class="trait" href="../../syn/parse/trait.Peek.html" title="trait syn::parse::Peek">Peek</a>&gt;(&amp;self, token: T) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/syn/parse.rs.html#577-580' title='goto source code'>[src]</a></h4><div class='docblock'><p>Looks at the third-next token in the parse stream.</p>
</div><h4 id='method.parse_terminated' class="method"><code id='parse_terminated.v'>pub fn <a href='#method.parse_terminated' class='fnname'>parse_terminated</a>&lt;T, P:&nbsp;<a class="trait" href="../../syn/parse/trait.Parse.html" title="trait syn::parse::Parse">Parse</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;parser: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.fn.html">fn</a>(_: <a class="type" href="../../syn/parse/type.ParseStream.html" title="type syn::parse::ParseStream">ParseStream</a>) -&gt; <a class="type" href="../../syn/parse/type.Result.html" title="type syn::parse::Result">Result</a>&lt;T&gt;<br>) -&gt; <a class="type" href="../../syn/parse/type.Result.html" title="type syn::parse::Result">Result</a>&lt;<a class="struct" href="../../syn/punctuated/struct.Punctuated.html" title="struct syn::punctuated::Punctuated">Punctuated</a>&lt;T, P&gt;&gt;</code><a class='srclink' href='../../src/syn/parse.rs.html#628-633' title='goto source code'>[src]</a></h4><div class='docblock'><p>Parses zero or more occurrences of <code>T</code> separated by punctuation of type
<code>P</code>, with optional trailing punctuation.</p>
<p>Parsing continues until the end of this parse stream. The entire content
of this parse stream must consist of <code>T</code> and <code>P</code>.</p>
<h1 id="example-3" class="section-header"><a href="#example-3">Example</a></h1>
<pre><code class="language-edition2018"># use quote::quote;
#
use syn::{parenthesized, token, Ident, Result, Token, Type};
use syn::parse::{Parse, ParseStream};
use syn::punctuated::Punctuated;

// Parse a simplified tuple struct syntax like:
//
//     struct S(A, B);
struct TupleStruct {
    struct_token: Token![struct],
    ident: Ident,
    paren_token: token::Paren,
    fields: Punctuated&lt;Type, Token![,]&gt;,
    semi_token: Token![;],
}

impl Parse for TupleStruct {
    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {
        let content;
        Ok(TupleStruct {
            struct_token: input.parse()?,
            ident: input.parse()?,
            paren_token: parenthesized!(content in input),
            fields: content.parse_terminated(Type::parse)?,
            semi_token: input.parse()?,
        })
    }
}
#
# fn main() {
#     let input = quote! {
#         struct S(A, B);
#     };
#     syn::parse2::&lt;TupleStruct&gt;(input).unwrap();
# }
</code></pre>
</div><h4 id='method.is_empty' class="method"><code id='is_empty.v'>pub fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/syn/parse.rs.html#672-674' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns whether there are tokens remaining in this stream.</p>
<p>This method returns true at the end of the content of a set of
delimiters, as well as at the very end of the complete macro input.</p>
<h1 id="example-4" class="section-header"><a href="#example-4">Example</a></h1>
<pre><code class="language-edition2018">use syn::{braced, token, Ident, Item, Result, Token};
use syn::parse::{Parse, ParseStream};

// Parses a Rust `mod m { ... }` containing zero or more items.
struct Mod {
    mod_token: Token![mod],
    name: Ident,
    brace_token: token::Brace,
    items: Vec&lt;Item&gt;,
}

impl Parse for Mod {
    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {
        let content;
        Ok(Mod {
            mod_token: input.parse()?,
            name: input.parse()?,
            brace_token: braced!(content in input),
            items: {
                let mut items = Vec::new();
                while !content.is_empty() {
                    items.push(content.parse()?);
                }
                items
            },
        })
    }
}
</code></pre>
</div><h4 id='method.lookahead1' class="method"><code id='lookahead1.v'>pub fn <a href='#method.lookahead1' class='fnname'>lookahead1</a>(&amp;self) -&gt; <a class="struct" href="../../syn/parse/struct.Lookahead1.html" title="struct syn::parse::Lookahead1">Lookahead1</a>&lt;'a&gt;</code><a class='srclink' href='../../src/syn/parse.rs.html#717-719' title='goto source code'>[src]</a></h4><div class='docblock'><p>Constructs a helper for peeking at the next token in this stream and
building an error message if it is not one of a set of expected tokens.</p>
<h1 id="example-5" class="section-header"><a href="#example-5">Example</a></h1>
<pre><code class="language-edition2018">use syn::{ConstParam, Ident, Lifetime, LifetimeDef, Result, Token, TypeParam};
use syn::parse::{Parse, ParseStream};

// A generic parameter, a single one of the comma-separated elements inside
// angle brackets in:
//
//     fn f&lt;T: Clone, 'a, 'b: 'a, const N: usize&gt;() { ... }
//
// On invalid input, lookahead gives us a reasonable error message.
//
//     error: expected one of: identifier, lifetime, `const`
//       |
//     5 |     fn f&lt;!Sized&gt;() {}
//       |          ^
enum GenericParam {
    Type(TypeParam),
    Lifetime(LifetimeDef),
    Const(ConstParam),
}

impl Parse for GenericParam {
    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {
        let lookahead = input.lookahead1();
        if lookahead.peek(Ident) {
            input.parse().map(GenericParam::Type)
        } else if lookahead.peek(Lifetime) {
            input.parse().map(GenericParam::Lifetime)
        } else if lookahead.peek(Token![const]) {
            input.parse().map(GenericParam::Const)
        } else {
            Err(lookahead.error())
        }
    }
}
</code></pre>
</div><h4 id='method.fork' class="method"><code id='fork.v'>pub fn <a href='#method.fork' class='fnname'>fork</a>(&amp;self) -&gt; Self</code><a class='srclink' href='../../src/syn/parse.rs.html#841-850' title='goto source code'>[src]</a></h4><div class='docblock'><p>Forks a parse stream so that parsing tokens out of either the original
or the fork does not advance the position of the other.</p>
<h1 id="performance" class="section-header"><a href="#performance">Performance</a></h1>
<p>Forking a parse stream is a cheap fixed amount of work and does not
involve copying token buffers. Where you might hit performance problems
is if your macro ends up parsing a large amount of content more than
once.</p>
<pre><code class="language-edition2018"># use syn::{Expr, Result};
# use syn::parse::ParseStream;
#
# fn bad(input: ParseStream) -&gt; Result&lt;Expr&gt; {
// Do not do this.
if input.fork().parse::&lt;Expr&gt;().is_ok() {
    return input.parse::&lt;Expr&gt;();
}
# unimplemented!()
# }
</code></pre>
<p>As a rule, avoid parsing an unbounded amount of tokens out of a forked
parse stream. Only use a fork when the amount of work performed against
the fork is small and bounded.</p>
<p>For a lower level but occasionally more performant way to perform
speculative parsing, consider using <a href="#method.step"><code>ParseStream::step</code></a> instead.</p>
<h1 id="example-6" class="section-header"><a href="#example-6">Example</a></h1>
<p>The parse implementation shown here parses possibly restricted <code>pub</code>
visibilities.</p>
<ul>
<li><code>pub</code></li>
<li><code>pub(crate)</code></li>
<li><code>pub(self)</code></li>
<li><code>pub(super)</code></li>
<li><code>pub(in some::path)</code></li>
</ul>
<p>To handle the case of visibilities inside of tuple structs, the parser
needs to distinguish parentheses that specify visibility restrictions
from parentheses that form part of a tuple type.</p>
<pre><code class="language-edition2018"># struct A;
# struct B;
# struct C;
#
struct S(pub(crate) A, pub (B, C));
</code></pre>
<p>In this example input the first tuple struct element of <code>S</code> has
<code>pub(crate)</code> visibility while the second tuple struct element has <code>pub</code>
visibility; the parentheses around <code>(B, C)</code> are part of the type rather
than part of a visibility restriction.</p>
<p>The parser uses a forked parse stream to check the first token inside of
parentheses after the <code>pub</code> keyword. This is a small bounded amount of
work performed against the forked parse stream.</p>
<pre><code class="language-edition2018">use syn::{parenthesized, token, Ident, Path, Result, Token};
use syn::ext::IdentExt;
use syn::parse::{Parse, ParseStream};

struct PubVisibility {
    pub_token: Token![pub],
    restricted: Option&lt;Restricted&gt;,
}

struct Restricted {
    paren_token: token::Paren,
    in_token: Option&lt;Token![in]&gt;,
    path: Path,
}

impl Parse for PubVisibility {
    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {
        let pub_token: Token![pub] = input.parse()?;

        if input.peek(token::Paren) {
            let ahead = input.fork();
            let mut content;
            parenthesized!(content in ahead);

            if content.peek(Token![crate])
                || content.peek(Token![self])
                || content.peek(Token![super])
            {
                return Ok(PubVisibility {
                    pub_token: pub_token,
                    restricted: Some(Restricted {
                        paren_token: parenthesized!(content in input),
                        in_token: None,
                        path: Path::from(content.call(Ident::parse_any)?),
                    }),
                });
            } else if content.peek(Token![in]) {
                return Ok(PubVisibility {
                    pub_token: pub_token,
                    restricted: Some(Restricted {
                        paren_token: parenthesized!(content in input),
                        in_token: Some(content.parse()?),
                        path: content.call(Path::parse_mod_style)?,
                    }),
                });
            }
        }

        Ok(PubVisibility {
            pub_token: pub_token,
            restricted: None,
        })
    }
}
</code></pre>
</div><h4 id='method.error' class="method"><code id='error.v'>pub fn <a href='#method.error' class='fnname'>error</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>&gt;(&amp;self, message: T) -&gt; <a class="struct" href="../../syn/struct.Error.html" title="struct syn::Error">Error</a></code><a class='srclink' href='../../src/syn/parse.rs.html#880-882' title='goto source code'>[src]</a></h4><div class='docblock'><p>Triggers an error at the current position of the parse stream.</p>
<h1 id="example-7" class="section-header"><a href="#example-7">Example</a></h1>
<pre><code class="language-edition2018">use syn::{Expr, Result, Token};
use syn::parse::{Parse, ParseStream};

// Some kind of loop: `while` or `for` or `loop`.
struct Loop {
    expr: Expr,
}

impl Parse for Loop {
    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {
        if input.peek(Token![while])
            || input.peek(Token![for])
            || input.peek(Token![loop])
        {
            Ok(Loop {
                expr: input.parse()?,
            })
        } else {
            Err(input.error(&quot;expected some kind of loop&quot;))
        }
    }
}
</code></pre>
</div><h4 id='method.step' class="method"><code id='step.v'>pub fn <a href='#method.step' class='fnname'>step</a>&lt;F, R&gt;(&amp;self, function: F) -&gt; <a class="type" href="../../syn/parse/type.Result.html" title="type syn::parse::Result">Result</a>&lt;R&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: for&lt;'c&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="struct" href="../../syn/parse/struct.StepCursor.html" title="struct syn::parse::StepCursor">StepCursor</a>&lt;'c, 'a&gt;) -&gt; <a class="type" href="../../syn/parse/type.Result.html" title="type syn::parse::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a>R, <a class="struct" href="../../syn/buffer/struct.Cursor.html" title="struct syn::buffer::Cursor">Cursor</a>&lt;'c&gt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;,&nbsp;</span></code><a class='srclink' href='../../src/syn/parse.rs.html#931-959' title='goto source code'>[src]</a></h4><div class='docblock'><p>Speculatively parses tokens from this parse stream, advancing the
position of this stream only if parsing succeeds.</p>
<p>This is a powerful low-level API used for defining the <code>Parse</code> impls of
the basic built-in token types. It is not something that will be used
widely outside of the Syn codebase.</p>
<h1 id="example-8" class="section-header"><a href="#example-8">Example</a></h1>
<pre><code class="language-edition2018">use proc_macro2::TokenTree;
use syn::Result;
use syn::parse::ParseStream;

// This function advances the stream past the next occurrence of `@`. If
// no `@` is present in the stream, the stream position is unchanged and
// an error is returned.
fn skip_past_next_at(input: ParseStream) -&gt; Result&lt;()&gt; {
    input.step(|cursor| {
        let mut rest = *cursor;
        while let Some((tt, next)) = rest.token_tree() {
            match &amp;tt {
                TokenTree::Punct(punct) if punct.as_char() == '@' =&gt; {
                    return Ok(((), next));
                }
                _ =&gt; rest = next,
            }
        }
        Err(cursor.error(&quot;no `@` was found after this point&quot;))
    })
}
#
# fn remainder_after_skipping_past_next_at(
#     input: ParseStream,
# ) -&gt; Result&lt;proc_macro2::TokenStream&gt; {
#     skip_past_next_at(input)?;
#     input.parse()
# }
#
# fn main() {
#     use syn::parse::Parser;
#     let remainder = remainder_after_skipping_past_next_at
#         .parse_str(&quot;a @ b c&quot;)
#         .unwrap();
#     assert_eq!(remainder.to_string(), &quot;b c&quot;);
# }
</code></pre>
</div><h4 id='method.cursor' class="method"><code id='cursor.v'>pub fn <a href='#method.cursor' class='fnname'>cursor</a>(&amp;self) -&gt; <a class="struct" href="../../syn/buffer/struct.Cursor.html" title="struct syn::buffer::Cursor">Cursor</a>&lt;'a&gt;</code><a class='srclink' href='../../src/syn/parse.rs.html#966-968' title='goto source code'>[src]</a></h4><div class='docblock'><p>Provides low-level access to the token representation underlying this
parse stream.</p>
<p>Cursors are immutable so no operations you perform against the cursor
will affect the state of this parse stream.</p>
</div></div><h2 id='implementations' class='small-section-header'>Trait Implementations<a href='#implementations' class='anchor'></a></h2><div id='implementations-list'><h3 id='impl-Drop' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="../../syn/parse/struct.ParseBuffer.html" title="struct syn::parse::ParseBuffer">ParseBuffer</a>&lt;'a&gt;</code><a href='#impl-Drop' class='anchor'></a><a class='srclink' href='../../src/syn/parse.rs.html#268-274' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.drop' class="method hidden"><code id='drop.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop' class='fnname'>drop</a>(&amp;mut self)</code><a class='srclink' href='../../src/syn/parse.rs.html#269-273' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Executes the destructor for this type. <a href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></p>
</div></div><h3 id='impl-Debug' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../../syn/parse/struct.ParseBuffer.html" title="struct syn::parse::ParseBuffer">ParseBuffer</a>&lt;'a&gt;</code><a href='#impl-Debug' class='anchor'></a><a class='srclink' href='../../src/syn/parse.rs.html#282-286' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt' class="method hidden"><code id='fmt.v'>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class='srclink' href='../../src/syn/parse.rs.html#283-285' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Display' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="../../syn/parse/struct.ParseBuffer.html" title="struct syn::parse::ParseBuffer">ParseBuffer</a>&lt;'a&gt;</code><a href='#impl-Display' class='anchor'></a><a class='srclink' href='../../src/syn/parse.rs.html#276-280' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt-1' class="method hidden"><code id='fmt.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class='srclink' href='../../src/syn/parse.rs.html#277-279' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></p>
</div></div></div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-Send' class='impl'><code class='in-band'>impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../../syn/parse/struct.ParseBuffer.html" title="struct syn::parse::ParseBuffer">ParseBuffer</a>&lt;'a&gt;</code><a href='#impl-Send' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><code class='in-band'>impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../../syn/parse/struct.ParseBuffer.html" title="struct syn::parse::ParseBuffer">ParseBuffer</a>&lt;'a&gt;</code><a href='#impl-Sync' class='anchor'></a></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-From' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a> for T</code><a href='#impl-From' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#546-548' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><code id='from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#547' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#537-542' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><code id='into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#539-541' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-ToString' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-ToString' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2122-2132' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_string' class="method hidden"><code id='to_string.v'>default fn <a href='https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string' class='fnname'>to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2124-2131' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></p>
</div></div><h3 id='impl-TryFrom' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryFrom' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#565-571' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><code id='Error.t'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method hidden"><code id='try_from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#568-570' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Borrow' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#213-215' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow' class="method hidden"><code id='borrow.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-Any' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#100-102' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.type_id' class="method hidden"><code id='type_id.v'>fn <a href='https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id' class='fnname'>type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#101' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id='impl-BorrowMut' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218-220' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow_mut' class="method hidden"><code id='borrow_mut.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#219' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-TryInto' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#553-560' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><code id='Error.t-1'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method hidden"><code id='try_into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#557-559' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "syn";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>